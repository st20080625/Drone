#include <arpa/inet.h>
#include <chrono>
#include <cstring>
#include <functional>
#include <memory>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include <std_msgs/msg/string.hpp>
#include <geometry_msgs/msg/transform_stamped.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2/LinearMath/Quaternion.h>
#include <string>
#include <sys/socket.h>
#include <thread>
#include <vector>

#define MAXBUF 1024
#define PI 3.1415926535
#define G 9.80665

using namespace std::chrono_literals;

class ImuPublisher : public rclcpp::Node {
public:
  ImuPublisher() : Node("imu_publisher"){
    rclcpp::Publisher<sensor_msgs::msg::Imu>SharedPtr imu_publisher_;
    std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
    imu_publisher_ = this->create_publisher<sensor_msgs::msg::Imu>("/imu/data", 10);
    tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);
    /*timer_ = this->create_wall_timer(
        500ms, std::bind(&ImuPublisher::timer_callback, this));*/
    if (InitSocket() != 0) {
      RCLCPP_ERROR(this->get_logger(), "Failed to initialize UDP socket");
      rclcpp::shutdown();
    }
    recv_thread_ = std::thread(&ImuPublisher::RecvImu, this);
  }

  ~ImuPublisher() {
    if (recv_thread_.joinable()) {
      recv_thread_.join();
    }
    close(sockfd);
  }
// 1byte単位で詰めてコンパイラの最適化で構造体のサイズが変わらないようにする
#pragma pack(push, 1)
  struct ImuData {
    float r, i, j, k;
    float acc_x, acc_y, acc_z;
    float gyro_x, gyro_y, gyro_z;
  };
#pragma pack(pop)

  int sockfd, len;
  unsigned char buf[MAXBUF];
  struct sockaddr_in udp_server_addr;
  struct sockaddr_storage client_storage;
  socklen_t addr_size, client_addr_size;
  ImuData RecvImuData;
  
private:
  /*void timer_callback() {
    auto message = std_msgs::msg::String();
    message.data = "Hello, world! " + std::to_string(count_++);
    RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
    publisher_->publish(message);
  }
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  size_t count_;*/
  std::thread recv_thread_;
  int InitSocket() {
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    if (sockfd < 0) {
      return 1;
    }
    udp_server_addr.sin_family = AF_INET;
    udp_server_addr.sin_port = htons(8001);
    udp_server_addr.sin_addr.s_addr = inet_addr("0.0.0.0");
    memset(udp_server_addr.sin_zero, '\0', sizeof(udp_server_addr));
    bind(sockfd, (struct sockaddr *)&udp_server_addr, sizeof(udp_server_addr));
    addr_size = sizeof(client_storage);
    return 0;
  }
  void RecvImu() {
    while (rclcpp::ok()) {
      len = recvfrom(sockfd, buf, MAXBUF, 0, (struct sockaddr *)&client_storage,
                     &addr_size);
      RCLCPP_DEBUG_STREAM(this->get_logger(),
                          "Received from client: " << len << "bytes\n"
                                                   << 4);
      if (len == sizeof(RecvImuData)) {
        memcpy(&RecvImuData, buf, sizeof(RecvImuData));
      }
      auto now = this->get_clock().now().to_msg();
      auto SendImuData = sensor_msgs::msg::Imu();
      SendImuData.header.stamp = now;
      SendImuData.header.frame_id = "imu_link";
      SendImuData.orientation.w = RecvImuData.r;
      SendImuData.orientation.x = RecvImuData.i;
      SendImuData.orientation.y = RecvImuData.j;
      SendImuData.orientation.z = RecvImuData.k;
      SendImuData.angular_velocity.x = RecvImuData.gyro_x * PI / 180.0;
      SendImuData.angular_velocity.y = RecvImuData.gyro_y * PI / 180.0;
      SendImuData.angular_velocity.z = RecvImuData.gyro_z * PI / 180.0;
      SendImuData.linear_acceleration.x = RecvImuData.acc_x * G;
      SendImuData.linear_acceleration.y = RecvImuData.acc_y * G;
      SendImuData.linear_acceleration.z = RecvImuData.acc_z * G;
      SendImuData.orientation_covariance = {0.001, 0.0, 0.0, 
                                            0.0,  0.001,0.0,
                                            0.0, 0.0, 0.001};
      SendImuData.angular_velocity_covariance = {0.001, 0.0, 0.0,
                                                 0.0,  0.001,0.0,
                                                 0.0, 0.0, 0.001};
      SendImuData.linear_acceleration_covariance = {0.5, 0.0, 0.0,
                                                    0.0, 0.5, 0.0,
                                                    0.0, 0.0, 0.5};
      geometry_msgs::TransformStamped t;
      t.header.stamp = now;
      t.header.frame_id = "base_link";
      t.child_frame_id = "imu_link";
      t.transform.rotation = SendImuData.orientation;
      t.transform.translation.x = 0.0;
      t.transform.translation.y = 0.0;
      t.transform.translation.z = 0.0;
      imu_publisher_->publish(SendImuData);
      tf_broadcaster_->sendTransform(t);
      std::this_thread::sleep_for(10ms);
    }
  }
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<ImuPublisher>());
  rclcpp::shutdown();
  return 0;
}
